https://blog.csdn.net/weixin_44587168/article/details/106203252?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_paycolumn_v3&utm_relevant_index=4

集合覆盖问题，给了思路，贪心，分支限界，遗传算法

https://optimization.cbe.cornell.edu/index.php?title=Set_covering_problem

看网上的介绍，维基百科里给的方法就只有线性规划和贪心算法

1. 贪心的思路

贪心的话就是我每次都选可覆盖最多元素的那个相机，并且这里的“可覆盖”的范围是目前未被覆盖的元素，并且选出来一个后，还要处理一下目前未被覆盖的元素集合，方便下一次继续选

代码层面的话，实际上<set>有一些操作可以直接用，set_intersection,set_difference之类的

具体不再做了，这种方法当然是最粗暴的方法，不过也显然是很慢的一种方法了

这里提醒我**回顾一下STL的一些函数**，map，set啥的在C++里叫关联容器

2.回溯/分支限界法

其实和leetcode0039，0040的题目还是挺类似的，我感觉子集和数问题真是理解回溯的最入门的例子了

但是有一个问题是，子集和数问题是有很明显的限界函数的，只要我已有的数超过了target就会剪枝，但是这个题目怎么剪枝？

我估计他就是因为有一些用例数据量非常的大，导致必须用剪枝，不然根本算不完。

这题主要的问题在于，我新加一个相机进去，它必然会向target方向前进，或者原地不动，而不是倒退。

那么我能想到的剪枝方法就两种：

- 如果我新加的相机使得我没有朝着target前进，那么我剪掉“使用这个相机”的分支，只留下“不使用这个相机的分支”
- 我初始想办法得到一个还不错的解，因为题目要求得到最少的相机，那么只要我的分支导致相机数超过了这个已经得到的解，就必然会舍弃这个分支

还是挺玄学的。。。

3. 遗传算法

这个就是很万金油式的方法了，我觉得最好还是掌握一下

第一种就是最传统的GA，遗传算法，01编码

第二种是DE，就是我大三做过的差分演化算法，实数编码

这个题显然要用到的是01编码了

不过也是，我不知道适应度函数咋设计。。。

难道我要先保证他覆盖了所有的点之后，再做选择？这样子的话，适应度函数就会变成min(相机数)了